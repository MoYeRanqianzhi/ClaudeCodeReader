# =============================================================================
# ClaudeCodeReader CI/CD 工作流
# =============================================================================
# 自动构建与发布工作流，支持以下三种触发方式：
#
#   1. Tag 推送 (v*):
#      → 构建并发布正式版 Release
#      → 构建所有平台的 Tauri 桌面应用
#      → 发布平台专属 NPM 包 + 主包到 NPM Registry
#
#   2. 分支推送 (任意分支):
#      → 构建并发布预发布版 Pre-release
#      → 仅上传到 GitHub Release，不发布到 NPM
#      → Release tag 格式: build-{YYYYMMDDHHmmss}-{short_sha}
#      → Release name 格式: Pre-release {version}+build.{YYYYMMDDHHmmss}
#
#   3. 手动触发 (workflow_dispatch):
#      → 指定已有 Tag 补发历史版本
#      → 用于修复发布失败等场景
#
# NPM 发布架构：
#   采用平台专属包模式（类似 esbuild/swc），每个平台有独立的 NPM 包，
#   包含预编译的二进制文件。主包通过 optionalDependencies 引用平台包，
#   npm 根据当前平台自动安装对应的包，无需 postinstall 下载。
# =============================================================================

name: Build & Release

on:
  push:
    branches: ['**']    # 所有分支推送 → 触发预发布构建
    tags: ['v*']        # v 前缀的标签推送 → 触发正式发布
  # 手动触发：用于补发历史版本（例如 CI 失败后重新发布）
  workflow_dispatch:
    inputs:
      tag:
        description: '要构建并发布的 Tag 名称（例如 v0.1.0-beta.4）'
        required: true
        type: string

# 并发控制：同一分支/标签上的多次推送只保留最新一次构建，取消旧的运行
# 避免浪费 CI 资源（特别是 Tauri 多平台构建较为耗时）
concurrency:
  group: build-${{ github.event.inputs.tag || github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================================================
  # Job 1: 准备阶段 — 判断发布类型、提取版本信息、生成变更日志
  # 该 Job 负责所有元数据计算，将结果通过 outputs 传递给下游 Job，
  # 避免在多个 Job 中重复判断逻辑。
  # ===========================================================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      # 是否为正式发布（true: tag 推送或手动触发; false: 分支推送预发布）
      is_release: ${{ steps.release_type.outputs.is_release }}
      # 用于 GitHub Release 的 tag 名称
      tag_name: ${{ steps.release_type.outputs.tag_name }}
      # Release 显示名称
      release_name: ${{ steps.release_type.outputs.release_name }}
      # 预发布构建的时间戳（仅预发布使用）
      timestamp: ${{ steps.release_type.outputs.timestamp }}
      # 从 package.json 提取的应用版本号（不含构建后缀）
      app_version: ${{ steps.version.outputs.version }}
      # 用于产物文件命名的版本号（预发布时包含 +build.TIMESTAMP 后缀）
      artifact_version: ${{ steps.release_type.outputs.artifact_version }}
      # 自动生成的变更日志内容
      changelog: ${{ steps.changelog.outputs.log }}

    steps:
      # 手动触发时 checkout 指定的 tag，否则 checkout 当前 ref
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}
          fetch-depth: 0    # 拉取完整 Git 历史，用于生成变更日志

      # 从 package.json 提取版本号，作为所有后续步骤的版本基准
      - name: Extract app version from package.json
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "App version: $VERSION"

      # 核心逻辑：根据触发来源判断是正式发布还是预发布
      # - refs/tags/v* 或 workflow_dispatch → 正式发布
      # - 分支推送 → 预发布
      - name: Determine release type
        id: release_type
        run: |
          INPUT_TAG="${{ github.event.inputs.tag }}"
          APP_VERSION="${{ steps.version.outputs.version }}"

          if [[ "${{ github.ref }}" == refs/tags/v* ]] || [[ -n "$INPUT_TAG" ]]; then
            # ---- 正式发布：Tag 推送 或 手动触发 ----
            TAG_NAME="${INPUT_TAG:-${{ github.ref_name }}}"

            echo "is_release=true" >> "$GITHUB_OUTPUT"
            echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"
            echo "release_name=ClaudeCodeReader ${APP_VERSION}" >> "$GITHUB_OUTPUT"
            # 正式发布：产物版本号与应用版本号一致
            echo "artifact_version=${APP_VERSION}" >> "$GITHUB_OUTPUT"
            echo "Release type: RELEASE (tag=$TAG_NAME, version=$APP_VERSION)"
          else
            # ---- 预发布：普通分支推送 ----
            # 使用 CST（中国标准时间）生成时间戳
            TIMESTAMP=$(TZ='Asia/Shanghai' date +%Y%m%d%H%M%S)
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

            echo "is_release=false" >> "$GITHUB_OUTPUT"
            # tag 格式使用 build-TIMESTAMP-SHA，保证按时间自然排序
            echo "tag_name=build-${TIMESTAMP}-${SHORT_SHA}" >> "$GITHUB_OUTPUT"
            echo "release_name=Pre-release ${APP_VERSION}+build.${TIMESTAMP}" >> "$GITHUB_OUTPUT"
            echo "timestamp=$TIMESTAMP" >> "$GITHUB_OUTPUT"
            # 预发布：产物版本号附加 +build.TIMESTAMP 后缀，用于区分不同构建
            echo "artifact_version=${APP_VERSION}+build.${TIMESTAMP}" >> "$GITHUB_OUTPUT"
            echo "Release type: PRE-RELEASE (sha=$SHORT_SHA, version=$APP_VERSION, timestamp=$TIMESTAMP)"
          fi

      # 自动生成变更日志：提取从上一个正式版 tag 到当前 HEAD 的所有提交
      - name: Generate changelog
        id: changelog
        run: |
          INPUT_TAG="${{ github.event.inputs.tag }}"
          IS_TAG_BUILD=false

          # 判断是否为 tag 构建（Tag 推送或手动触发）
          if [[ "${{ github.ref }}" == refs/tags/v* ]] || [[ -n "$INPUT_TAG" ]]; then
            IS_TAG_BUILD=true
            CURRENT_TAG="${INPUT_TAG:-${{ github.ref_name }}}"
          fi

          # 查找上一个正式版 tag（v* 格式，按版本号降序排列）
          # 如果是 tag 构建，需要排除当前 tag 自身，否则会得到空的变更记录
          if [ "$IS_TAG_BUILD" = true ]; then
            LAST_TAG=$(git tag -l 'v*' --sort=-v:refname | grep -v "^${CURRENT_TAG}$" | head -n1 2>/dev/null || echo "")
          else
            LAST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n1 2>/dev/null || echo "")
          fi

          echo "Last release tag: ${LAST_TAG:-'(none)'}"

          # 生成变更日志
          if [ -n "$LAST_TAG" ]; then
            # 有历史 tag：提取从上一个 tag 到 HEAD 的所有非合并提交
            LOG=$(git log "${LAST_TAG}..HEAD" --pretty=format:"- %s (\`%h\`)" --no-merges)
          else
            # 没有历史 tag（首次发布）：取最近 30 条提交
            LOG=$(git log --pretty=format:"- %s (\`%h\`)" --no-merges -30)
          fi

          # 使用 EOF 定界符处理多行输出，避免特殊字符转义问题
          {
            echo "log<<EOF"
            echo "$LOG"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # ===========================================================================
  # Job 2: 创建 GitHub Release
  # 根据 prepare Job 的判断结果，创建正式版或预发布版的 GitHub Release。
  # ===========================================================================
  create-release:
    needs: prepare    # 依赖 prepare Job 完成，获取发布类型和元数据
    runs-on: ubuntu-latest
    permissions:
      contents: write    # 需要写权限才能创建 Release 和上传资产
    outputs:
      # 统一的 Release ID，由 set_release_id 步骤根据发布类型合并正式版/预发布版的输出
      release_id: ${{ steps.set_release_id.outputs.id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      # ---- 正式版 Release ----
      # 所有 v* tag 推送或手动触发时创建，一律标记为正式版（包括 beta/alpha）。
      # beta/alpha 版本仅在 NPM 发布时使用 --tag beta 区分，GitHub Release 不做预发布标记。
      - name: Create Release
        if: needs.prepare.outputs.is_release == 'true'
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag_name }}
          name: ${{ needs.prepare.outputs.release_name }}
          draft: false
          prerelease: false
          generate_release_notes: true
          body: |
            ## ClaudeCodeReader ${{ needs.prepare.outputs.app_version }}

            ### 更新内容

            ${{ needs.prepare.outputs.changelog }}

            ---
            *完整变更日志见下方 GitHub 自动生成的内容。*
          make_latest: true

      # ---- 预发布版 Pre-release ----
      # 分支推送时创建，标记为预发布，不影响 latest 标记
      - name: Create Pre-release
        if: needs.prepare.outputs.is_release == 'false'
        id: create_prerelease
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag_name }}
          name: ${{ needs.prepare.outputs.release_name }}
          draft: false
          prerelease: true
          generate_release_notes: false
          body: |
            ## 预发布版 ClaudeCodeReader ${{ needs.prepare.outputs.app_version }}

            > ⚠️ 此版本为自动构建的预发布版本，可能不稳定，仅供测试使用。

            | 信息 | 值 |
            |------|-----|
            | **分支** | `${{ github.ref_name }}` |
            | **提交** | `${{ github.sha }}` |
            | **构建时间 (CST)** | `${{ needs.prepare.outputs.timestamp }}` |

            ### 本次提交

            ${{ github.event.head_commit.message }}

            ### 变更记录

            ${{ needs.prepare.outputs.changelog }}
          make_latest: false

      # 统一输出 Release ID（无论正式版还是预发布版）
      # 使用条件表达式合并两个 step 的输出，供下游 build-tauri Job 使用
      - name: Set release ID output
        id: set_release_id
        run: |
          if [ "${{ needs.prepare.outputs.is_release }}" = "true" ]; then
            echo "id=${{ steps.create_release.outputs.id }}" >> "$GITHUB_OUTPUT"
          else
            echo "id=${{ steps.create_prerelease.outputs.id }}" >> "$GITHUB_OUTPUT"
          fi

  # ===========================================================================
  # Job 3: 在多个平台上并行构建 Tauri 桌面应用
  # 依赖 create-release Job，需要 Release ID 来上传构建产物。
  # 构建完成后将 .exe/.dmg/.deb/.AppImage 等安装包上传到 GitHub Release，
  # 并将 NPM 平台包所需的二进制文件作为 artifact 上传供 publish-npm 使用。
  # ===========================================================================
  build-tauri:
    needs: [prepare, create-release]    # 同时依赖 prepare（元数据）和 create-release（Release ID）
    permissions:
      contents: write                   # 需要写权限来上传构建产物到 Release
    strategy:
      # fail-fast: false — 即使某个平台构建失败，其他平台仍继续构建。
      # 这样可以最大化成功产物数量，避免因单平台问题阻塞所有发布。
      fail-fast: false
      matrix:
        include:
          # ---- macOS ARM64 (Apple Silicon: M1/M2/M3/M4) ----
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            target: 'aarch64-apple-darwin'
            npm_pkg: 'darwin-arm64'
          # ---- macOS x86_64 (Intel Mac) ----
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            target: 'x86_64-apple-darwin'
            npm_pkg: 'darwin-x64'
          # ---- Linux x86_64 (Ubuntu 22.04) ----
          - platform: 'ubuntu-22.04'
            args: ''
            target: ''
            npm_pkg: 'linux-x64'
          # ---- Windows x86_64 (使用 NSIS 安装器格式) ----
          - platform: 'windows-latest'
            args: '--bundles nsis'
            target: ''
            npm_pkg: 'win32-x64'

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}    # 安装交叉编译目标（macOS 需要）

      # Ubuntu 构建依赖：
      # - libwebkit2gtk-4.1-dev: Tauri 的 WebView 渲染引擎（Linux 上使用 WebKitGTK）
      # - libappindicator3-dev:  系统托盘图标支持
      # - librsvg2-dev:          SVG 图标渲染（应用图标处理）
      # - patchelf:              修改 ELF 二进制文件的动态链接路径
      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: npm ci

      # Tauri 官方 GitHub Action：仅执行构建，不自动上传到 Release。
      # 构建完成后由后续步骤统一重命名产物（预发布时添加 +build.TIMESTAMP 后缀）再上传。
      - name: Build Tauri
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: ${{ matrix.args }}

      # 构建后统一处理：收集所有产物、重命名版本号、上传到 Release。
      # 预发布时将文件名中的 app_version 替换为 artifact_version（含 +build.TIMESTAMP），
      # 正式发布时两者相同，重命名为无操作。
      # 同时处理各平台的额外产物（Windows 独立 .exe、macOS .app.tar.gz）。
      - name: Collect and rename artifacts
        shell: bash
        run: |
          APP_VERSION="${{ needs.prepare.outputs.app_version }}"
          ARTIFACT_VERSION="${{ needs.prepare.outputs.artifact_version }}"
          mkdir -p upload

          # 遍历 bundle 目录下所有构建产物，重命名后复制到 upload 目录
          find src-tauri/target -path '*/bundle/*' -type f \
            \( -name '*.exe' -o -name '*.dmg' -o -name '*.AppImage' -o -name '*.deb' -o -name '*.sig' \) \
            | while read -r f; do
              BASENAME=$(basename "$f")
              NEW_NAME="${BASENAME//$APP_VERSION/$ARTIFACT_VERSION}"
              cp "$f" "upload/$NEW_NAME"
              echo "Collected: $BASENAME -> $NEW_NAME"
            done

          # Windows 额外产物：复制独立 .exe 二进制文件（供 GitHub Release 直接下载）
          if [ -f "src-tauri/target/release/claude-code-reader.exe" ]; then
            cp src-tauri/target/release/claude-code-reader.exe "upload/ClaudeCodeReader_${ARTIFACT_VERSION}_x64.exe"
            echo "Collected: standalone Windows exe"
          fi

          # macOS 额外产物：将 .app 目录打包为 tar.gz（供 GitHub Release 下载）
          TARGET="${{ matrix.target }}"
          if [ -n "$TARGET" ] && [ -d "src-tauri/target/${TARGET}/release/bundle/macos/ClaudeCodeReader.app" ]; then
            cd "src-tauri/target/${TARGET}/release/bundle/macos"
            tar -czvf "${GITHUB_WORKSPACE}/upload/ClaudeCodeReader_${ARTIFACT_VERSION}_${TARGET}.app.tar.gz" ClaudeCodeReader.app
            cd "${GITHUB_WORKSPACE}"
            echo "Collected: macOS .app.tar.gz for ${TARGET}"
          fi

          echo "=== Upload directory ==="
          ls -la upload/

      - name: Upload artifacts to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag_name }}
          files: upload/*

      # -----------------------------------------------------------------------
      # 准备 NPM 平台包的二进制文件 artifact
      # 将构建产物复制到 npm-binary/bin/ 目录，供 publish-npm Job 使用。
      # 每个平台的二进制文件格式不同：
      # - Windows: 独立 .exe 可执行文件
      # - macOS:   完整的 .app 应用束目录
      # - Linux:   AppImage 单文件可执行包
      # -----------------------------------------------------------------------
      - name: Prepare NPM binary artifact
        shell: bash
        run: |
          mkdir -p npm-binary/bin

          # Windows: 复制独立 .exe 可执行文件
          if [ "${{ matrix.npm_pkg }}" = "win32-x64" ]; then
            cp src-tauri/target/release/claude-code-reader.exe npm-binary/bin/ClaudeCodeReader.exe
            echo "Prepared: Windows exe for NPM package"
          fi

          # macOS ARM64: 复制完整的 .app 应用束目录
          if [ "${{ matrix.npm_pkg }}" = "darwin-arm64" ]; then
            cp -R src-tauri/target/aarch64-apple-darwin/release/bundle/macos/ClaudeCodeReader.app npm-binary/bin/ClaudeCodeReader.app
            echo "Prepared: macOS ARM64 .app for NPM package"
          fi

          # macOS x64: 复制完整的 .app 应用束目录
          if [ "${{ matrix.npm_pkg }}" = "darwin-x64" ]; then
            cp -R src-tauri/target/x86_64-apple-darwin/release/bundle/macos/ClaudeCodeReader.app npm-binary/bin/ClaudeCodeReader.app
            echo "Prepared: macOS x64 .app for NPM package"
          fi

          # Linux: 复制 AppImage 文件
          if [ "${{ matrix.npm_pkg }}" = "linux-x64" ]; then
            cp src-tauri/target/release/bundle/appimage/*.AppImage npm-binary/bin/ClaudeCodeReader.AppImage
            echo "Prepared: Linux AppImage for NPM package"
          fi

          echo "=== NPM binary directory ==="
          ls -laR npm-binary/

      # 上传 NPM 二进制 artifact，供 publish-npm Job 下载使用。
      # artifact 名称格式: npm-{platform}（如 npm-win32-x64），
      # 用于在 publish-npm Job 中按平台标识下载对应的二进制文件。
      - name: Upload NPM binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: npm-${{ matrix.npm_pkg }}
          path: npm-binary/
          retention-days: 1    # artifact 仅用于同次工作流内传递，1 天后自动清理

  # ===========================================================================
  # Job 4: 发布 NPM 包（平台专属包 + 主包）
  # 仅在正式发布时执行（Tag 推送或手动触发），预发布不发布到 NPM。
  #
  # 采用平台专属包架构：
  # 1. 先发布 4 个平台包（claude-code-reader-{platform}），每个包含对应平台的二进制文件
  # 2. 再发布主包（claude-code-reader），通过 optionalDependencies 引用平台包
  # npm 安装主包时会根据当前系统自动选择并安装匹配的平台包。
  # ===========================================================================
  publish-npm:
    needs: [prepare, build-tauri]    # 等待元数据准备和所有平台构建完成
    # 仅正式发布时才执行 NPM 发布，预发布版本不推送到 NPM，避免污染包版本
    if: needs.prepare.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'    # 配置 NPM Registry 地址

      # 下载所有平台的 NPM 二进制 artifact 到 platform-artifacts/ 目录。
      # 每个 artifact 以 npm-{platform} 命名，下载后目录结构为：
      # platform-artifacts/
      #   npm-win32-x64/bin/ClaudeCodeReader.exe
      #   npm-darwin-arm64/bin/ClaudeCodeReader.app/
      #   npm-darwin-x64/bin/ClaudeCodeReader.app/
      #   npm-linux-x64/bin/ClaudeCodeReader.AppImage
      - name: Download all NPM binary artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: npm-*
          path: platform-artifacts/

      # 从 Git 标签提取版本号，供后续发布步骤使用
      - name: Determine version and NPM tag
        id: npm_info
        run: |
          TAG_NAME="${{ needs.prepare.outputs.tag_name }}"
          VERSION="${TAG_NAME#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

          # 判断 NPM 发布标签：beta/alpha 版本使用 --tag beta，正式版使用 latest
          if [[ "$VERSION" == *"beta"* ]] || [[ "$VERSION" == *"alpha"* ]]; then
            echo "npm_tag=beta" >> "$GITHUB_OUTPUT"
          else
            echo "npm_tag=latest" >> "$GITHUB_OUTPUT"
          fi

          echo "Version: $VERSION, NPM tag: $(if [[ "$VERSION" == *"beta"* ]] || [[ "$VERSION" == *"alpha"* ]]; then echo beta; else echo latest; fi)"

      # -----------------------------------------------------------------------
      # 循环发布 4 个平台专属包
      # 对每个平台：
      # 1. 创建临时发布目录
      # 2. 动态生成 package.json（包含 name、version、os、cpu 等字段）
      # 3. 复制对应平台的二进制文件到 bin/ 目录
      # 4. 执行 npm publish 发布到 NPM Registry
      #
      # 平台包必须先于主包发布，否则主包的 optionalDependencies 无法解析。
      # -----------------------------------------------------------------------
      - name: Publish platform packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          VERSION="${{ steps.npm_info.outputs.version }}"
          NPM_TAG="${{ steps.npm_info.outputs.npm_tag }}"

          # 定义 4 个平台的配置：包名后缀、os 字段值、cpu 字段值
          declare -A PLATFORMS
          PLATFORMS=(
            ["win32-x64"]="win32 x64"
            ["darwin-arm64"]="darwin arm64"
            ["darwin-x64"]="darwin x64"
            ["linux-x64"]="linux x64"
          )

          for PLATFORM_KEY in "${!PLATFORMS[@]}"; do
            read -r OS CPU <<< "${PLATFORMS[$PLATFORM_KEY]}"
            PKG_NAME="claude-code-reader-${PLATFORM_KEY}"
            ARTIFACT_DIR="platform-artifacts/npm-${PLATFORM_KEY}"

            echo "========================================="
            echo "Publishing ${PKG_NAME}@${VERSION}"
            echo "========================================="

            # 检查 artifact 目录是否存在（构建可能失败导致缺失）
            if [ ! -d "$ARTIFACT_DIR" ]; then
              echo "WARNING: Artifact directory not found: $ARTIFACT_DIR, skipping..."
              continue
            fi

            # 创建临时发布目录
            PUBLISH_DIR="publish-${PLATFORM_KEY}"
            mkdir -p "$PUBLISH_DIR"

            # 复制二进制文件目录
            cp -R "${ARTIFACT_DIR}/bin" "${PUBLISH_DIR}/bin"

            # 动态生成 package.json
            # os 和 cpu 字段告诉 npm 此包仅适用于指定的平台和架构，
            # npm 在安装 optionalDependencies 时会自动跳过不匹配的包。
            cat > "${PUBLISH_DIR}/package.json" << PKGJSON
          {
            "name": "${PKG_NAME}",
            "version": "${VERSION}",
            "description": "Platform-specific binary for ClaudeCodeReader (${OS} ${CPU})",
            "license": "MIT",
            "repository": {
              "type": "git",
              "url": "git+https://github.com/MoYeRanQianZhi/ClaudeCodeReader.git"
            },
            "os": ["${OS}"],
            "cpu": ["${CPU}"],
            "files": ["bin"]
          }
          PKGJSON

            echo "Generated package.json:"
            cat "${PUBLISH_DIR}/package.json"

            echo "Binary files:"
            ls -laR "${PUBLISH_DIR}/bin/"

            # 发布到 NPM Registry
            cd "$PUBLISH_DIR"
            npm publish --access public --tag "$NPM_TAG"
            cd ..

            echo "Successfully published ${PKG_NAME}@${VERSION}"
          done

      # -----------------------------------------------------------------------
      # 发布主包 claude-code-reader
      # 更新版本号和 optionalDependencies 中各平台包的版本号后发布。
      # 主包本身不包含二进制文件，仅包含 ccr.js 入口脚本和平台包引用。
      # -----------------------------------------------------------------------
      - name: Publish main package
        working-directory: npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          VERSION="${{ steps.npm_info.outputs.version }}"
          NPM_TAG="${{ steps.npm_info.outputs.npm_tag }}"

          # 更新主包版本号
          npm version "$VERSION" --no-git-tag-version --allow-same-version

          # 更新 optionalDependencies 中所有平台包的版本号，
          # 确保与当前发布的平台包版本一致
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const deps = pkg.optionalDependencies || {};
            for (const name of Object.keys(deps)) {
              deps[name] = '${VERSION}';
            }
            pkg.optionalDependencies = deps;
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          echo "Updated package.json:"
          cat package.json

          # 修复 package.json 中可能存在的格式问题
          npm pkg fix

          # 发布主包到 NPM Registry
          npm publish --access public --tag "$NPM_TAG"

          echo "Successfully published claude-code-reader@${VERSION}"
